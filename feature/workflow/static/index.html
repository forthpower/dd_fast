<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workflowå¯è§†åŒ–å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .top-bar {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            align-items: stretch;
            flex-wrap: wrap;
        }

        .header {
            background: white;
            border-radius: 10px;
            padding: 12px 16px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            flex: 1 1 320px;
        }

        .header h1 {
            color: #2c3e50;
            font-size: 20px;
            margin-bottom: 4px;
        }

        .header p {
            color: #7f8c8d;
            font-size: 13px;
        }

        .upload-section {
            background: white;
            border-radius: 10px;
            padding: 12px 16px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            text-align: center;
            flex: 1 1 320px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .upload-area {
            border: 2px dashed #3498db;
            border-radius: 8px;
            padding: 20px 16px;
            background: #f8f9fa;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .upload-area:hover {
            border-color: #2980b9;
            background: #ecf0f1;
        }

        .upload-area.dragover {
            border-color: #27ae60;
            background: #d4edda;
        }

        .upload-icon {
            font-size: 36px;
            margin-bottom: 8px;
        }

        .upload-text {
            color: #2c3e50;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .upload-hint {
            color: #7f8c8d;
            font-size: 12px;
        }

        .filter-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            background: #f9fafb;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 12px 16px;
            margin-bottom: 12px;
        }

        .filter-field {
            flex: 1 1 180px;
            min-width: 150px;
        }

        .filter-field label {
            display: block;
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 4px;
        }

        .filter-field select,
        .filter-field input {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 13px;
            color: #374151;
        }

        .filter-actions {
            display: flex;
            gap: 8px;
            align-items: flex-end;
        }

        .table-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 12px;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
            margin: 0;
        }

        .edit-input,
        .edit-select {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #cbd5f5;
            border-radius: 4px;
            font-size: 12px;
        }

        .action-cell {
            white-space: nowrap;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
            margin: 0;
        }

        #fileInput {
            display: none;
        }

        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        .btn-success {
            background: #27ae60;
        }

        .btn-success:hover {
            background: #229954;
        }

        .btn-danger {
            background: #e74c3c;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .workflow-container {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            display: none;
        }


        .loading {
            text-align: center;
            padding: 60px 20px;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #7f8c8d;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }
 

        .error-message {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }

        /* Splitæ ·å¼ */
        .splits-container {
            display: none;
        }

        /* è¡¨æ ¼æ’åºæ ·å¼ */
        .sortable-header {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 20px !important;
        }

        .sortable-header:hover {
            background-color: #e9ecef !important;
        }

        .sortable-header::after {
            content: 'â‡…';
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            color: #6c757d;
            opacity: 0.5;
        }

        .sortable-header.sort-asc::after {
            content: 'â†‘';
            opacity: 1;
            color: #3498db;
        }

        .sortable-header.sort-desc::after {
            content: 'â†“';
            opacity: 1;
            color: #3498db;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="top-bar">
            <div class="header">
                <h1>ğŸ”€ Workflowå¸ç§åˆ†é‡è§£æ</h1>
                <p>ä¸Šä¼ JSONæ–‡ä»¶ï¼Œè§£æå¹¶æ˜¾ç¤ºå¸ç§åˆ†é‡ä¿¡æ¯</p>
            </div>
            <div class="upload-section">
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">ğŸ“</div>
                    <div class="upload-text">ç‚¹å‡»æˆ–æ‹–æ‹½JSONæ–‡ä»¶åˆ°è¿™é‡Œ</div>
                    <div class="upload-hint">æ”¯æŒ .json æ ¼å¼æ–‡ä»¶</div>
                    <input type="file" id="fileInput" accept=".json">
                </div>
            </div>
        </div>

        <!-- Workflowå¯è§†åŒ–åŠŸèƒ½ -->
        <div class="feature-content active" id="visualizeFeature">
        <div class="workflow-container" id="workflowContainer">
            <!-- å¸ç§åˆ†é‡æ˜¾ç¤º -->
                <div class="splits-container" id="splitsContainer"></div>

            <div class="loading" id="loadingState" style="display: none;">
                <div class="loading-spinner"></div>
                <p>æ­£åœ¨è§£ææ–‡ä»¶...</p>
            </div>

            <div class="empty-state" id="emptyState">
                <div class="empty-state-icon">ğŸ“‹</div>
                <p>è¯·ä¸Šä¼ JSONæ–‡ä»¶ä»¥å¼€å§‹è§£æ</p>
            </div>
        </div>
    </div>

    <script>
        let workflowData = null;
        let uploadedFile = null;  // ä¿å­˜ä¸Šä¼ çš„æ–‡ä»¶
        let uploadedFileName = '';
        let originalUploadedJson = null;
        let originalJsonIsTable = false;
        let originalJsonRowIdMap = [];
        let removedOriginalRowIds = new Set();
        let currentSort = { column: null, direction: null };  // å½“å‰æ’åºçŠ¶æ€
        let allCSVRows = [];  // ä¿å­˜æ‰€æœ‰CSVè¡Œæ•°æ®ï¼Œç”¨äºæ’åº
        let filterState = {
            paymentMethod: 'all',
            network: 'all',
            affinity: 'all',
            adaptive3ds: 'all',
            tokenized: 'all'
        };
        let editingRowId = null;
        let rowIdCounter = 0;
        const editableFields = ['æ”¯ä»˜æ–¹å¼','Network','å¸ç§','å¼€å¯Affinity','Adaptive 3DS','å¤‡æ³¨','Network Tokenizedï¼Ÿ','Adyen','Stripe','Airwallex'];

        function generateRowId() {
            return `row_${Date.now()}_${rowIdCounter++}`;
        }

        function cloneRow(row) {
            const clone = {};
            Object.keys(row || {}).forEach(key => {
                if (key === '_id') return;
                clone[key] = row[key];
            });
            return clone;
        }

        // æ–‡ä»¶ä¸Šä¼ å¤„ç†
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('click', () => fileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        async function handleFile(file) {
            if (!file.name.endsWith('.json')) {
                alert('è¯·ä¸Šä¼ JSONæ ¼å¼æ–‡ä»¶');
                return;
            }

            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('loadingState').style.display = 'block';
            document.getElementById('workflowContainer').style.display = 'none';

            try {
                uploadedFileName = file.name;
                // ä¸Šä¼ åˆ°åç«¯è§£æ
                const formData = new FormData();
                formData.append('file', file);

                const response = await fetch('/api/parse', {
                    method: 'POST',
                    body: formData
                });

                const fileText = await file.text();
                try {
                    originalUploadedJson = JSON.parse(fileText);
                    originalJsonIsTable = Array.isArray(originalUploadedJson) && originalUploadedJson.every(item => typeof item === 'object');
                } catch (err) {
                    originalUploadedJson = null;
                    originalJsonIsTable = false;
                }
                originalJsonRowIdMap = [];
                removedOriginalRowIds = new Set();
                const result = await response.json();

                if (result.success) {
                    workflowData = result.data;
                    uploadedFile = file;  // ä¿å­˜æ–‡ä»¶å¼•ç”¨
                    // ä¼˜å…ˆä½¿ç”¨CSVæ ¼å¼æ•°æ®ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨splits
                    if (result.data.csv_format) {
                        renderSplitsFromCSV(result.data.csv_format);
                    } else {
                        renderSplits(result.data.splits || []);
                    }
                    document.getElementById('loadingState').style.display = 'none';
                    document.getElementById('workflowContainer').style.display = 'block';
                } else {
                    throw new Error(result.error || 'è§£æå¤±è´¥');
                }
            } catch (error) {
                document.getElementById('loadingState').style.display = 'none';
                document.getElementById('emptyState').style.display = 'block';
                
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = 'è§£æå¤±è´¥: ' + error.message;
                document.querySelector('.container').appendChild(errorDiv);
            }
        }


        // æ’åºå‡½æ•°
        function sortCSVRows(rows, column, direction) {
            if (!column) return rows;
            
            return [...rows].sort((a, b) => {
                let aVal = a[column] || '';
                let bVal = b[column] || '';
                
                // å¤„ç†æ•°å­—ç±»å‹ï¼ˆAdyen, Stripe, Airwallexï¼‰
                if (['Adyen', 'Stripe', 'Airwallex'].includes(column)) {
                    aVal = parseFloat(aVal) || 0;
                    bVal = parseFloat(bVal) || 0;
                } else {
                    // å­—ç¬¦ä¸²ç±»å‹ï¼Œè½¬æ¢ä¸ºå­—ç¬¦ä¸²æ¯”è¾ƒ
                    aVal = String(aVal);
                    bVal = String(bVal);
                }
                
                let comparison = 0;
                if (aVal < bVal) {
                    comparison = -1;
                } else if (aVal > bVal) {
                    comparison = 1;
                }
                
                return direction === 'asc' ? comparison : -comparison;
            });
        }

        function applyFilters(rows) {
            if (!rows || rows.length === 0) return [];
            return rows.filter(row => {
                if (filterState.paymentMethod !== 'all' && row['æ”¯ä»˜æ–¹å¼'] !== filterState.paymentMethod) {
                    return false;
                }
                if (filterState.network !== 'all' && row['Network'] !== filterState.network) {
                    return false;
                }
                if (filterState.affinity !== 'all' && row['å¼€å¯Affinity'] !== filterState.affinity) {
                    return false;
                }
                if (filterState.adaptive3ds !== 'all' && row['Adaptive 3DS'] !== filterState.adaptive3ds) {
                    return false;
                }
                if (filterState.tokenized !== 'all' && row['Network Tokenizedï¼Ÿ'] != filterState.tokenized) {
                    return false;
                }
                return true;
            });
        }

        function buildFilterControls(baseRows = []) {
            const paymentOptions = Array.from(new Set(baseRows.map(row => row['æ”¯ä»˜æ–¹å¼']).filter(Boolean))).sort();
            const networkOptions = Array.from(new Set(baseRows.map(row => row['Network']).filter(Boolean))).sort();
            const affinityOptions = Array.from(new Set(baseRows.map(row => row['å¼€å¯Affinity']).filter(Boolean))).sort();
            const adaptiveOptions = Array.from(new Set(baseRows.map(row => row['Adaptive 3DS']).filter(Boolean))).sort();
            const tokenizedOptions = Array.from(new Set(baseRows.map(row => row['Network Tokenizedï¼Ÿ']).filter(Boolean))).sort();

            const wrapper = document.createElement('div');
            wrapper.className = 'filter-controls';

            const createSelectField = (labelText, options, currentValue, onChange) => {
                const field = document.createElement('div');
                field.className = 'filter-field';
                const label = document.createElement('label');
                label.textContent = labelText;
                const select = document.createElement('select');
                select.innerHTML = `<option value="all">å…¨éƒ¨</option>` + options.map(opt => `<option value="${opt}">${opt}</option>`).join('');
                select.value = currentValue;
                select.addEventListener('change', (e) => onChange(e.target.value));
                field.appendChild(label);
                field.appendChild(select);
                return field;
            };

            const paymentField = createSelectField('æ”¯ä»˜æ–¹å¼', paymentOptions, filterState.paymentMethod, (value) => {
                filterState.paymentMethod = value;
                renderSplitsFromCSV(null, { skipSave: true });
            });

            const networkField = createSelectField('Network', networkOptions, filterState.network, (value) => {
                filterState.network = value;
                renderSplitsFromCSV(null, { skipSave: true });
            });

            const affinityField = createSelectField('å¼€å¯Affinity', affinityOptions, filterState.affinity, (value) => {
                filterState.affinity = value;
                renderSplitsFromCSV(null, { skipSave: true });
            });

            const adaptiveField = createSelectField('Adaptive 3DS', adaptiveOptions, filterState.adaptive3ds, (value) => {
                filterState.adaptive3ds = value;
                renderSplitsFromCSV(null, { skipSave: true });
            });

            const tokenizedField = createSelectField('Network Tokenizedï¼Ÿ', tokenizedOptions, filterState.tokenized, (value) => {
                filterState.tokenized = value;
                renderSplitsFromCSV(null, { skipSave: true });
            });

            const actions = document.createElement('div');
            actions.className = 'filter-actions';
            const resetBtn = document.createElement('button');
            resetBtn.type = 'button';
            resetBtn.className = 'btn btn-small';
            resetBtn.textContent = 'é‡ç½®ç­›é€‰';
            resetBtn.addEventListener('click', () => {
                filterState = {
                    paymentMethod: 'all',
                    network: 'all',
                    affinity: 'all',
                    adaptive3ds: 'all',
                    tokenized: 'all'
                };
                renderSplitsFromCSV(null, { skipSave: true });
            });
            actions.appendChild(resetBtn);

            wrapper.appendChild(paymentField);
            wrapper.appendChild(networkField);
            wrapper.appendChild(affinityField);
            wrapper.appendChild(adaptiveField);
            wrapper.appendChild(tokenizedField);
            wrapper.appendChild(actions);

            return wrapper;
        }

        // å¤„ç†æ’åºç‚¹å‡»
        function handleSort(column) {
            // å¦‚æœç‚¹å‡»çš„æ˜¯åŒä¸€åˆ—ï¼Œåˆ‡æ¢æ’åºæ–¹å‘
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                // æ–°åˆ—ï¼Œé»˜è®¤å‡åº
                currentSort.column = column;
                currentSort.direction = 'asc';
            }
            
            // é‡æ–°æ¸²æŸ“è¡¨æ ¼ï¼ˆä½¿ç”¨å·²ä¿å­˜çš„æ•°æ®ï¼‰
            if (workflowData && workflowData.csv_format) {
                renderSplitsFromCSV(null, { skipSave: true });
            } else if (workflowData && workflowData.splits) {
                renderSplits(workflowData.splits);
            } else if (allCSVRows.length > 0) {
                renderSplitsFromCSV(null, { skipSave: true });
            }
        }

        
        // è¾…åŠ©å‡½æ•°ï¼šè·å–é»˜è®¤Network
        function getDefaultNetwork(paymentMethod) {
            const mapping = {
                'CARD': 'Mastercard Visa JCB',
                'AP': '',
                'GP': 'éAmex'
            };
            return mapping[paymentMethod] || '';
        }
        
        // è¾…åŠ©å‡½æ•°ï¼šè·å–é»˜è®¤Affinity
        function getDefaultAffinity(paymentMethod, currency) {
            if (paymentMethod === 'AP') {
                return currency !== 'å…¶ä»–' ? 'æ˜¯' : 'å¦';
            }
            return 'æ˜¯';
        }
        
        // è¾…åŠ©å‡½æ•°ï¼šè·å–é»˜è®¤Adaptive 3DS
        function getDefaultAdaptive3DS(paymentMethod) {
            const mapping = {
                'CARD': 'éƒ¨åˆ†å¼€å¯',
                'AP': 'å¦',
                'GP': 'å¦'
            };
            return mapping[paymentMethod] || 'å¦';
        }
        
        // è¾…åŠ©å‡½æ•°ï¼šè·å–é»˜è®¤Tokenized
        function getDefaultTokenized(paymentMethod) {
            return paymentMethod === 'GP' ? 'TRUE' : '';
        }
        
        // è¾…åŠ©å‡½æ•°ï¼šä»CSVæ”¯ä»˜æ–¹å¼åç§°è·å–æ˜¾ç¤ºåç§°
        function getPaymentMethodDisplayNameFromCSV(csvName) {
            const mapping = {
                'Card': 'ğŸ’³ Card',
                'Apple Pay': 'ğŸ Apple Pay',
                'Google Pay': 'ğŸ“± Google Pay'
            };
            return mapping[csvName] || csvName;
        }

        // ä»CSVæ ¼å¼æ•°æ®æ¸²æŸ“ï¼ˆä¼˜å…ˆä½¿ç”¨ï¼‰
        function renderSplitsFromCSV(csvData, options = {}) {
            const { skipSave = false } = options;
            const container = document.getElementById('splitsContainer');
            container.innerHTML = '';
            container.style.display = 'block';

            if (!skipSave && csvData) {
                const normalizedRows = [];
                if (Array.isArray(csvData)) {
                    csvData.forEach(row => normalizedRows.push({ ...row }));
                } else if (csvData && typeof csvData === 'object') {
                    Object.keys(csvData).forEach(paymentMethod => {
                        const currencies = csvData[paymentMethod];
                        Object.keys(currencies || {}).forEach(currency => {
                            const [adyen, stripe, airwallex] = currencies[currency];
                            normalizedRows.push({
                                'æ”¯ä»˜æ–¹å¼': getPaymentMethodCSVName(paymentMethod),
                                'Network': getDefaultNetwork(paymentMethod),
                                'å¸ç§': currency,
                                'å¼€å¯Affinity': getDefaultAffinity(paymentMethod, currency),
                                'Adaptive 3DS': getDefaultAdaptive3DS(paymentMethod),
                                'å¤‡æ³¨': '',
                                'Network Tokenizedï¼Ÿ': getDefaultTokenized(paymentMethod),
                                'Adyen': adyen,
                                'Stripe': stripe,
                                'Airwallex': airwallex
                            });
                        });
                    });
                }

                if (normalizedRows.length) {
                    allCSVRows = normalizedRows.map(row => ({
                        ...row,
                        _id: row._id || generateRowId()
                    }));
                } else {
                    allCSVRows = [];
                }
                editingRowId = null;
                filterState = {
                    paymentMethod: 'all',
                    network: 'all',
                    affinity: 'all',
                    adaptive3ds: 'all',
                    tokenized: 'all'
                };
                if (originalJsonIsTable) {
                    originalJsonRowIdMap = allCSVRows.map(row => row._id);
                    removedOriginalRowIds = new Set();
                } else {
                    originalJsonRowIdMap = [];
                    removedOriginalRowIds = new Set();
                }
                if (!allCSVRows.length) {
                    container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ğŸ”€</div><p>æœªæ‰¾åˆ°SplitèŠ‚ç‚¹</p></div>';
                    return;
                }
            }

            if (!allCSVRows.length) {
                container.appendChild(buildTableActions());
                const emptyDiv = document.createElement('div');
                emptyDiv.className = 'empty-state';
                emptyDiv.innerHTML = '<div class="empty-state-icon">ğŸ”€</div><p>æœªæ‰¾åˆ°SplitèŠ‚ç‚¹</p>';
                container.appendChild(emptyDiv);
                return;
            }

            container.appendChild(buildFilterControls(allCSVRows));
            container.appendChild(buildTableActions());

            const filteredRows = applyFilters(allCSVRows);
            const rowsToRender = currentSort.column
                ? sortCSVRows(filteredRows, currentSort.column, currentSort.direction)
                : filteredRows;

            if (!rowsToRender.length) {
                const emptyFiltered = document.createElement('div');
                emptyFiltered.className = 'empty-state';
                emptyFiltered.innerHTML = '<div class="empty-state-icon">ğŸ”</div><p>æœªæ‰¾åˆ°åŒ¹é…çš„æ•°æ®</p>';
                container.appendChild(emptyFiltered);
                return;
            }

            const tableContainer = document.createElement('div');
            tableContainer.style.cssText = 'background: white; border-radius: 10px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); overflow-x: auto;';

            const table = document.createElement('table');
            table.style.cssText = 'width: 100%; border-collapse: collapse; font-size: 13px;';

            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            headerRow.style.cssText = 'background: #f8f9fa; border-bottom: 2px solid #dee2e6;';

            const sortableColumns = [
                { name: 'æ”¯ä»˜æ–¹å¼', align: 'left' },
                { name: 'Network', align: 'left' },
                { name: 'å¸ç§', align: 'left' },
                { name: 'å¼€å¯Affinity', align: 'center' },
                { name: 'Adaptive 3DS', align: 'center' },
                { name: 'å¤‡æ³¨', align: 'left' },
                { name: 'Network Tokenizedï¼Ÿ', align: 'center' },
                { name: 'Adyen', align: 'center' },
                { name: 'Stripe', align: 'center' },
                { name: 'Airwallex', align: 'center' }
            ];

            sortableColumns.forEach(col => {
                const th = document.createElement('th');
                th.textContent = col.name;
                th.style.cssText = `padding: 10px 8px; text-align: ${col.align}; font-weight: bold; color: #2c3e50; border-bottom: 2px solid #dee2e6; white-space: nowrap;`;
                th.className = 'sortable-header';
                if (currentSort.column === col.name) {
                    th.classList.add(`sort-${currentSort.direction}`);
                }
                th.addEventListener('click', () => handleSort(col.name));
                headerRow.appendChild(th);
            });

            const actionHeader = document.createElement('th');
            actionHeader.textContent = 'æ“ä½œ';
            actionHeader.style.cssText = 'padding: 10px 8px; text-align: center; font-weight: bold; color: #2c3e50; border-bottom: 2px solid #dee2e6; white-space: nowrap;';
            headerRow.appendChild(actionHeader);

            thead.appendChild(headerRow);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');

            if (currentSort.column) {
                rowsToRender.forEach(row => appendTableRow(tbody, row));
            } else {
                const paymentMethodGroups = {};
                rowsToRender.forEach(row => {
                    const pm = row['æ”¯ä»˜æ–¹å¼'];
                    if (!paymentMethodGroups[pm]) paymentMethodGroups[pm] = [];
                    paymentMethodGroups[pm].push(row);
                });

                const paymentOrder = ['Card', 'Apple Pay', 'Google Pay'];
                paymentOrder.forEach(pm => {
                    if (!paymentMethodGroups[pm] || paymentMethodGroups[pm].length === 0) return;
                    const methodRow = document.createElement('tr');
                    methodRow.style.cssText = 'background: #e9ecef;';
                    methodRow.innerHTML = `
                        <td colspan="11" style="padding: 10px 12px; font-weight: bold; color: #2c3e50; font-size: 16px;">
                            ${getPaymentMethodDisplayNameFromCSV(pm)}
                        </td>
                    `;
                    tbody.appendChild(methodRow);

                    paymentMethodGroups[pm]
                        .sort((a, b) => (a['å¸ç§'] || '').localeCompare(b['å¸ç§'] || ''))
                        .forEach(row => appendTableRow(tbody, row));
                });

                Object.keys(paymentMethodGroups).forEach(pm => {
                    if (paymentOrder.includes(pm)) return;
                    const methodRow = document.createElement('tr');
                    methodRow.style.cssText = 'background: #e9ecef;';
                    methodRow.innerHTML = `
                        <td colspan="11" style="padding: 10px 12px; font-weight: bold; color: #2c3e50; font-size: 16px;">
                            ${pm}
                        </td>
                    `;
                    tbody.appendChild(methodRow);

                    paymentMethodGroups[pm].forEach(row => appendTableRow(tbody, row));
                });
            }

            table.appendChild(tbody);
            table.addEventListener('click', handleTableClick);
            tableContainer.appendChild(table);
            container.appendChild(tableContainer);
        }

        function buildTableActions() {
            const bar = document.createElement('div');
            bar.className = 'table-actions';

            const addBtn = document.createElement('button');
            addBtn.type = 'button';
            addBtn.className = 'btn btn-small btn-success';
            addBtn.textContent = 'æ–°å¢ä¸€è¡Œ';
            addBtn.addEventListener('click', addNewRow);

            const exportBtn = document.createElement('button');
            exportBtn.type = 'button';
            exportBtn.className = 'btn btn-small btn-success';
            exportBtn.textContent = 'å¯¼å‡º JSON';
            exportBtn.addEventListener('click', exportJSON);

            bar.appendChild(addBtn);
            bar.appendChild(exportBtn);
            return bar;
        }

        function appendTableRow(tbody, row) {
            const tr = document.createElement('tr');
            tr.style.cssText = 'border-bottom: 1px solid #dee2e6;';
            tr.dataset.rowId = row._id || '';
            const isEditing = editingRowId === row._id;
            const fields = ['æ”¯ä»˜æ–¹å¼','Network','å¸ç§','å¼€å¯Affinity','Adaptive 3DS','å¤‡æ³¨','Network Tokenizedï¼Ÿ','Adyen','Stripe','Airwallex'];

            fields.forEach(field => {
                const td = document.createElement('td');
                const centerFields = ['å¼€å¯Affinity','Adaptive 3DS','Network Tokenizedï¼Ÿ','Adyen','Stripe','Airwallex'];
                td.style.cssText = `padding: 8px; color: #495057;${centerFields.includes(field) ? 'text-align: center;' : ''}`;

                if (isEditing) {
                    td.appendChild(createEditorControl(field, row[field]));
                } else {
                    td.textContent = formatCellValue(field, row[field]);
                }
                tr.appendChild(td);
            });

            const actionTd = document.createElement('td');
            actionTd.className = 'action-cell';
            if (isEditing) {
                const saveBtn = document.createElement('button');
                saveBtn.type = 'button';
                saveBtn.className = 'btn btn-small btn-success';
                saveBtn.textContent = 'ä¿å­˜';
                saveBtn.dataset.action = 'save';
                saveBtn.dataset.id = row._id;

                const cancelBtn = document.createElement('button');
                cancelBtn.type = 'button';
                cancelBtn.className = 'btn btn-small';
                cancelBtn.style.marginLeft = '4px';
                cancelBtn.textContent = 'å–æ¶ˆ';
                cancelBtn.dataset.action = 'cancel';

                actionTd.appendChild(saveBtn);
                actionTd.appendChild(cancelBtn);
            } else {
                const editBtn = document.createElement('button');
                editBtn.type = 'button';
                editBtn.className = 'btn btn-small';
                editBtn.textContent = 'ç¼–è¾‘';
                editBtn.dataset.action = 'edit';
                editBtn.dataset.id = row._id;

                const deleteBtn = document.createElement('button');
                deleteBtn.type = 'button';
                deleteBtn.className = 'btn btn-small btn-danger';
                deleteBtn.style.marginLeft = '4px';
                deleteBtn.textContent = 'åˆ é™¤';
                deleteBtn.dataset.action = 'delete';
                deleteBtn.dataset.id = row._id;

                actionTd.appendChild(editBtn);
                actionTd.appendChild(deleteBtn);
            }
            tr.appendChild(actionTd);
            tbody.appendChild(tr);
        }

        function createEditorControl(field, value) {
            const normalizedValue = value === undefined || value === null ? '' : value;
            if (field === 'å¼€å¯Affinity') {
                return createSelectControl(field, normalizedValue, ['', 'æ˜¯', 'å¦']);
            }
            if (field === 'Adaptive 3DS') {
                return createSelectControl(field, normalizedValue, ['', 'å¦', 'éƒ¨åˆ†å¼€å¯']);
            }
            if (field === 'Network Tokenizedï¼Ÿ') {
                return createSelectControl(field, normalizedValue, ['', 'TRUE', 'False']);
            }
            const input = document.createElement('input');
            input.type = ['Adyen','Stripe','Airwallex'].includes(field) ? 'number' : 'text';
            if (input.type === 'number') {
                input.min = 0;
                input.max = 100;
                input.step = '1';
                input.value = normalizedValue === 'æ— åˆ†é‡' ? '' : normalizedValue;
            } else {
                input.value = normalizedValue;
            }
            input.className = 'edit-input';
            input.dataset.field = field;
            return input;
        }

        function createSelectControl(field, currentValue, options) {
            const select = document.createElement('select');
            select.className = 'edit-select';
            select.dataset.field = field;
            options.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt;
                option.textContent = opt === '' ? 'ç©º' : opt;
                if (opt === currentValue) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
            return select;
        }

        function handleTableClick(event) {
            const action = event.target.dataset.action;
            if (!action) return;
            const rowId = event.target.dataset.id;
            const rowElement = event.target.closest('tr');

            if (action === 'edit') {
                startEditRow(rowId);
            } else if (action === 'delete') {
                deleteRow(rowId);
            } else if (action === 'save') {
                saveRow(rowId, rowElement);
            } else if (action === 'cancel') {
                cancelEditRow();
            }
        }

        function startEditRow(rowId) {
            editingRowId = rowId;
            renderSplitsFromCSV(null, { skipSave: true });
        }

        function cancelEditRow() {
            editingRowId = null;
            renderSplitsFromCSV(null, { skipSave: true });
        }

        function deleteRow(rowId) {
            if (!rowId) return;
            const target = allCSVRows.find(row => row._id === rowId);
            if (!target) return;
            if (originalJsonIsTable) {
                const idx = originalJsonRowIdMap.indexOf(rowId);
                if (idx !== -1) {
                    removedOriginalRowIds.add(rowId);
                }
            }
            allCSVRows = allCSVRows.filter(row => row._id !== rowId);
            if (editingRowId === rowId) {
                editingRowId = null;
            }
            renderSplitsFromCSV(null, { skipSave: true });
        }

        function addNewRow() {
            const newRow = {
                _id: generateRowId(),
                'æ”¯ä»˜æ–¹å¼': '',
                'Network': '',
                'å¸ç§': '',
                'å¼€å¯Affinity': '',
                'Adaptive 3DS': '',
                'å¤‡æ³¨': '',
                'Network Tokenizedï¼Ÿ': '',
                'Adyen': '',
                'Stripe': '',
                'Airwallex': ''
            };
            allCSVRows.push(newRow);
            editingRowId = newRow._id;
            renderSplitsFromCSV(null, { skipSave: true });
        }

        function saveRow(rowId, rowElement) {
            if (!rowId || !rowElement) return;
            const targetRow = allCSVRows.find(row => row._id === rowId);
            if (!targetRow) return;

            const controls = rowElement.querySelectorAll('[data-field]');
            controls.forEach(control => {
                const field = control.dataset.field;
                let value = control.value;
                if (['Adyen','Stripe','Airwallex'].includes(field)) {
                    if (value === '' || value === null) {
                        targetRow[field] = '';
                    } else {
                        targetRow[field] = Number(value);
                    }
                } else {
                    targetRow[field] = value;
                }
            });

            editingRowId = null;
            renderSplitsFromCSV(null, { skipSave: true });
        }

        function exportJSON() {
            if (!allCSVRows.length) {
                alert('æš‚æ— å¯å¯¼å‡ºçš„æ•°æ®');
                return;
            }
            const idToRow = new Map();
            allCSVRows.forEach(row => {
                idToRow.set(row._id, cloneRow(row));
            });
            let exportPayload;
            if (originalJsonIsTable && Array.isArray(originalUploadedJson)) {
                const merged = [];
                originalJsonRowIdMap.forEach((rowId, idx) => {
                    if (removedOriginalRowIds.has(rowId)) {
                        return;
                    }
                    const originalItem = originalUploadedJson[idx] ? { ...originalUploadedJson[idx] } : {};
                    if (rowId && idToRow.has(rowId)) {
                        merged.push({
                            ...originalItem,
                            ...idToRow.get(rowId)
                        });
                        idToRow.delete(rowId);
                    } else {
                        merged.push(originalItem);
                    }
                });
                idToRow.forEach(row => {
                    merged.push({ ...row });
                });
                exportPayload = merged;
            } else {
                exportPayload = Array.from(idToRow.values()).map(row => ({ ...row }));
            }

            const filename = (uploadedFileName && uploadedFileName.endsWith('.json')) ? uploadedFileName : (uploadedFileName ? `${uploadedFileName}.json` : 'workflow_table.json');
            const jsonText = JSON.stringify(exportPayload, null, 2);
            const blob = new Blob([jsonText], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function formatCellValue(field, value) {
            if (value === null || value === undefined) return '';
            if (['Adyen','Stripe','Airwallex'].includes(field)) {
                if (value === '' || value === 'æ— åˆ†é‡') {
                    return value || '';
                }
                return `${value}%`;
            }
            return String(value);
        }

        function getSerializableRows() {
            return allCSVRows.map(row => cloneRow(row));
        }

        function renderSplits(splits) {
            const container = document.getElementById('splitsContainer');
            container.innerHTML = '';
            container.style.display = 'block';

            if (!splits || splits.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ğŸ”€</div><p>æœªæ‰¾åˆ°SplitèŠ‚ç‚¹</p></div>';
                return;
            }

            const csvData = convertSplitsToCSVFormat(splits);
            const tableContainer = document.createElement('div');
            tableContainer.style.cssText = 'background: white; border-radius: 10px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); overflow-x: auto;';

            const table = document.createElement('table');
            table.style.cssText = 'width: 100%; border-collapse: collapse; font-size: 14px;';

            const thead = document.createElement('thead');
            thead.innerHTML = `
                <tr style="background: #f8f9fa; border-bottom: 2px solid #dee2e6;">
                    <th style="padding: 12px; text-align: left; font-weight: bold; color: #2c3e50; border-bottom: 2px solid #dee2e6;">æ”¯ä»˜æ–¹å¼</th>
                    <th style="padding: 12px; text-align: left; font-weight: bold; color: #2c3e50; border-bottom: 2px solid #dee2e6;">å¸ç§</th>
                    <th style="padding: 12px; text-align: center; font-weight: bold; color: #2c3e50; border-bottom: 2px solid #dee2e6;">Adyen</th>
                    <th style="padding: 12px; text-align: center; font-weight: bold; color: #2c3e50; border-bottom: 2px solid #dee2e6;">Stripe</th>
                    <th style="padding: 12px; text-align: center; font-weight: bold; color: #2c3e50; border-bottom: 2px solid #dee2e6;">Airwallex</th>
                </tr>
            `;
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            const paymentMethods = ['CARD', 'AP', 'GP'];
            paymentMethods.forEach(paymentMethod => {
                if (!csvData[paymentMethod] || Object.keys(csvData[paymentMethod]).length === 0) {
                    return;
                }

                const methodRow = document.createElement('tr');
                methodRow.style.cssText = 'background: #e9ecef;';
                methodRow.innerHTML = `
                    <td colspan="5" style="padding: 10px 12px; font-weight: bold; color: #2c3e50; font-size: 16px;">
                        ${getPaymentMethodDisplayName(paymentMethod)}
                    </td>
                `;
                tbody.appendChild(methodRow);

                Object.keys(csvData[paymentMethod]).sort().forEach(currency => {
                    const percentages = csvData[paymentMethod][currency];
                    const [adyen, stripe, airwallex] = percentages;

                    const row = document.createElement('tr');
                    row.style.cssText = 'border-bottom: 1px solid #dee2e6;';
                    row.innerHTML = `
                        <td style="padding: 10px 12px; color: #495057;">${getPaymentMethodCSVName(paymentMethod)}</td>
                        <td style="padding: 10px 12px; color: #495057; font-weight: 500;">${escapeHtml(currency)}</td>
                        <td style="padding: 10px 12px; text-align: center; color: #495057;">${adyen}%</td>
                        <td style="padding: 10px 12px; text-align: center; color: #495057;">${stripe}%</td>
                        <td style="padding: 10px 12px; text-align: center; color: #495057;">${airwallex}%</td>
                    `;
                    tbody.appendChild(row);
                });
            });

            Object.keys(csvData).forEach(paymentMethod => {
                if (paymentMethods.includes(paymentMethod)) {
                    return;
                }
                const methodRow = document.createElement('tr');
                methodRow.style.cssText = 'background: #e9ecef;';
                methodRow.innerHTML = `
                    <td colspan="5" style="padding: 10px 12px; font-weight: bold; color: #2c3e50; font-size: 16px;">
                        ${paymentMethod}
                    </td>
                `;
                tbody.appendChild(methodRow);

                Object.keys(csvData[paymentMethod]).sort().forEach(currency => {
                    const percentages = csvData[paymentMethod][currency];
                    const [adyen, stripe, airwallex] = percentages;

                    const row = document.createElement('tr');
                    row.style.cssText = 'border-bottom: 1px solid #dee2e6;';
                    row.innerHTML = `
                        <td style="padding: 10px 12px; color: #495057;">${paymentMethod}</td>
                        <td style="padding: 10px 12px; color: #495057; font-weight: 500;">${escapeHtml(currency)}</td>
                        <td style="padding: 10px 12px; text-align: center; color: #495057;">${adyen}%</td>
                        <td style="padding: 10px 12px; text-align: center; color: #495057;">${stripe}%</td>
                        <td style="padding: 10px 12px; text-align: center; color: #495057;">${airwallex}%</td>
                    `;
                    tbody.appendChild(row);
                });
            });

            table.appendChild(tbody);
            tableContainer.appendChild(table);
            container.appendChild(tableContainer);
        }

        // å°†splitæ•°æ®è½¬æ¢ä¸ºCSVæ ¼å¼ï¼š{æ”¯ä»˜æ–¹å¼: {å¸ç§: [Adyen%, Stripe%, Airwallex%]}}
        function convertSplitsToCSVFormat(splits) {
            const csvData = {};
            
            splits.forEach(split => {
                // è·å–æ”¯ä»˜æ–¹å¼å’Œå¸ç§
                let paymentMethod = split.payment_method || 'UNKNOWN';
                let currency = split.currency || 'å…¶ä»–';
                
                // å¦‚æœåç«¯æ²¡æœ‰æä¾›ï¼Œå°è¯•ä»æ¡ä»¶ä¸­æå–
                if (paymentMethod === 'UNKNOWN' || currency === 'å…¶ä»–') {
                    const condition = split.condition;
                    if (condition && condition.expression) {
                        const expr = condition.expression.toLowerCase();
                        
                        if (paymentMethod === 'UNKNOWN') {
                            if (expr.includes('card') || expr.includes('cARD')) {
                                paymentMethod = 'CARD';
                            } else if (expr.includes('apple') || expr.includes('ap')) {
                                paymentMethod = 'AP';
                            } else if (expr.includes('google') || expr.includes('gp')) {
                                paymentMethod = 'GP';
                            }
                        }
                        
                        if (currency === 'å…¶ä»–') {
                            const currencyPatterns = [
                                /currency[:\s]*["']?([a-z]{3})["']?/i,
                                /å¸ç§[:\s]*["']?([^"'\s]+)["']?/i,
                                /["']([a-z]{3})["']/i
                            ];
                            
                            for (const pattern of currencyPatterns) {
                                const match = expr.match(pattern);
                                if (match && match[1]) {
                                    currency = match[1].toUpperCase();
                                    break;
                                }
                            }
                        }
                    }
                    
                    // å¦‚æœä»ç„¶æ— æ³•æå–ï¼Œå°è¯•ä»splitåç§°æå–
                    if (paymentMethod === 'UNKNOWN') {
                        const splitName = (split.name || '').toLowerCase();
                        if (splitName.includes('card')) paymentMethod = 'CARD';
                        else if (splitName.includes('apple') || splitName.includes('ap')) paymentMethod = 'AP';
                        else if (splitName.includes('google') || splitName.includes('gp')) paymentMethod = 'GP';
                    }
                }
                
                // ä»routesä¸­æå–åˆ†é‡ï¼ˆé€šå¸¸routeså¯¹åº”Adyen, Stripe, Airwallexï¼‰
                // å‡è®¾routesçš„é¡ºåºæ˜¯ï¼šAdyen, Stripe, Airwallex
                const routes = split.routes || [];
                let adyen = 0, stripe = 0, airwallex = 0;
                
                // å°è¯•ä»routeåç§°åŒ¹é…
                routes.forEach(route => {
                    const routeName = (route.name || '').toLowerCase();
                    const percentage = route.percentage || 0;
                    
                    if (routeName.includes('adyen') || routeName.includes('ady')) {
                        adyen = percentage;
                    } else if (routeName.includes('stripe') || routeName.includes('str')) {
                        stripe = percentage;
                    } else if (routeName.includes('airwallex') || routeName.includes('awx') || routeName.includes('air')) {
                        airwallex = percentage;
                    }
                });
                
                // å¦‚æœæ— æ³•ä»åç§°åŒ¹é…ï¼ŒæŒ‰é¡ºåºåˆ†é…ï¼ˆå‡è®¾å‰ä¸‰ä¸ªrouteåˆ†åˆ«æ˜¯Adyen, Stripe, Airwallexï¼‰
                if (adyen === 0 && stripe === 0 && airwallex === 0 && routes.length >= 3) {
                    adyen = routes[0].percentage || 0;
                    stripe = routes[1].percentage || 0;
                    airwallex = routes[2].percentage || 0;
                } else if (routes.length === 3) {
                    // å¦‚æœåªæœ‰3ä¸ªroutesï¼ŒæŒ‰é¡ºåºåˆ†é…
                    adyen = routes[0].percentage || 0;
                    stripe = routes[1].percentage || 0;
                    airwallex = routes[2].percentage || 0;
                }
                
                // åˆå¹¶ç›¸åŒæ”¯ä»˜æ–¹å¼å’Œå¸ç§çš„åˆ†é‡ï¼ˆå–å¹³å‡å€¼æˆ–ç¬¬ä¸€ä¸ªï¼‰
                if (!csvData[paymentMethod]) {
                    csvData[paymentMethod] = {};
                }
                
                if (!csvData[paymentMethod][currency]) {
                    csvData[paymentMethod][currency] = [adyen, stripe, airwallex];
                    } else {
                    // å¦‚æœå·²å­˜åœ¨ï¼Œåˆå¹¶åˆ†é‡ï¼ˆè¿™é‡Œç®€å•å–ç¬¬ä¸€ä¸ªï¼Œä¹Ÿå¯ä»¥å–å¹³å‡å€¼ï¼‰
                    // csvData[paymentMethod][currency] = [adyen, stripe, airwallex];
                }
            });
            
            return csvData;
        }
        
        // è·å–æ”¯ä»˜æ–¹å¼CSVæ˜¾ç¤ºåç§°
        function getPaymentMethodCSVName(method) {
            const names = {
                'CARD': 'Card',
                'AP': 'Apple Pay',
                'GP': 'Google Pay'
            };
            return names[method] || method;
        }
        
        // è·å–æ”¯ä»˜æ–¹å¼æ˜¾ç¤ºåç§°
        function getPaymentMethodDisplayName(method) {
            const names = {
                'CARD': 'ğŸ’³ Card',
                'AP': 'ğŸ Apple Pay',
                'GP': 'ğŸ“± Google Pay',
                'UNKNOWN': 'â“ æœªçŸ¥æ”¯ä»˜æ–¹å¼'
            };
            return names[method] || method;
        }

        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
    </script>
</body>
</html>
